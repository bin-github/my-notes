#### Java类加载
##### 1、加载步骤：
> 1、加载：
>> 1、通过一个类的全限定名来获取定义此类的二进制字节流，二进制流可以来自jar，zip，war，网络等等。   
>> 2、将字节流转化为方法区的运行时数据结构    
>> 3、在Java堆中生成一个能代表该类的java.lang.Class对象，作为方法区数据的访问入口    
>> 4、只有如下的**5类主动引用**才会触发类加载：
>>> 1、遇到new（使用new 关键字实例化一个对象）、getstatic（读取一个类的静态字段）、putstatic或者invokestatic（设置一个类的静态字段）这4条指令的时候，如果类没有进行过初始化。则需要先触发其初始化需要先加载。    
>>> 2、使用反射调用时，类未初始化，则触发其初始化需要先加载     
>>> 3、初始化子类时父类没有初始化，则触发其父类的初始化需要先加载    
>>> 4、程序运行main方法时，先要初始化该类需要先加载      
>>> 5、使用动态代理时，解析结果为REF_getStatic、REF_pusStatic、REF_invokeStatic的方法句柄（句柄中包含了对象的实例数据和类型数据，句柄是访问对象的一种方法。句柄存储在堆中），并且句柄对应的类没有被初始化，那么需要先触发这个类的初始化需要先加载      

>> 5、**被动引用**不会触发类加载：
>>> 1、子类使用父类的静态字段，子类不会初始化：    
>>> 2、类数组Class[] arry = new Class[2]，此类引用不会触发     
>>> 3、类中的常量。


>> 类加载示意图
![image](https://note.youdao.com/yws/api/personal/file/F1E501CE81794B2FBFED1C857553F7DF?method=download&shareKey=fb3c205ea25faabf7f7a9fc6ac6e8b79)

> 2、验证：检验当前Class文件的字节流包含的信息是否符合当前虚拟机的要求，且保证虚拟机自身安全

> 3、准备：正式为类变量（ static）分配内存并设置初始值（并非定义的初始值而是初始零值，只有final修饰的变量才会被直接初始化）的阶段，

> 4、解析：将常量池中的符号引用（一组符号来描述所引用的目标）替换为直接引用

> 5、初始化：执行Java语句，如各个属性的复制操作，类的构造方法等

> 6、使用：

> 7、卸载：

##### 2、类加载器：
> 1、启动类加载器：Bootstrap ClassLoader：
>> 1、主要加载JDK\jre\lib目录下的类，rt.jar等     
>> 2、是使用c++实现，与虚拟机实现有关，不能直接在Java中引用继承。

> 2、扩展类加载器：Extension ClassLoader：
>> 1、在Java中的实现类是sun.misc.Launcher$ExtClassLoader类，主要负责加载的路径是JDK\jre\lib\ext目录下或者java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）     
>> 2、开发者可以直接使用该类加载器

> 3、应用程序类加载器：Application ClassLoader：
>> 1、在Java中的实现类sun.misc.Launcher$AppClassLoader，负责加载用户类路径（ClassPath）所指定的类。

> 4、自定义类加载器：MyClassLoader extends ClassLoader：
>> 1、自定义实现类加载器，及主要是继承ClassLoader类，重写其 findClass(String name) 方法。     
>> 2、优势：
>>> 1、在执行非置信代码之前，自动验证数字签名。     
>>> 2、动态地创建符合用户特定需要的定制化构建类。    
>>> 3、从特定的场所取得java class，例如数据库中和网络中 

> 5、双亲委派：
>> 1、一个类加载器要加载一个类时，它不会自己先加载，而是将其交给父类加载器去加载，依次递归，直到Bootstrap ClassLoader类加载器，如果不能加载，再原路返回依次试各个类加载器。这些类加载器之间不是继承关系，而是使用组合关系来公用类加载代码。
