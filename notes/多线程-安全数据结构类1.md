### 安全数据结构类
#### 1、Collection集合类：
##### 1、CopyOnWriteArrayList：
> 1、线程安全类list，底层使用数组实现；

> 2、add方法使用可重入锁保证线程同步，每次添加新元素时，使用Arrays.copyOf()扩充数组，添加元素的效率较低，而且随着集合元素数量的增大效率会越来越低。

```
public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            // 这个copy方法将原来的数组对象与要修该的数组对象分成两部分，
            //内存消耗是一般list的二倍，但是好处是在get元素时不用做任何
            //同步操作，因为同一个时刻，写入的和读取的不会是同一个数组对象
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
// get时无需同步，因为同一个时刻，写入的和读取的不会是同一个数组对象
public E get(int index) {
        return get(getArray(), index);
    }
```
> 3、插入元素的效率低，读取元素的效率高，适合少插入，多读取的场景

##### 2、CopyOnWriteArraySet：
> 1、线程安全的set，底层是使用CopyOnWriteArrayList实现的，其实就是在CopyOnWriteArrayList上加了一些元素去重的操作。

```
// 构造方法
public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList<E>();
    }
```
##### 3、Collections.synchronizedList(new ArrayList<>())：
> 1、集合框架的辅助类，将集合类的对象引用进行处理，主要是添加对象相关的锁，使得在操作对象的时候可以使用这个锁进行同步，使用的都是关键字synchronized（mutex）去同步操作方法。

```
public static <T> List<T> synchronizedList(List<T> list) {
        return (list instanceof RandomAccess ?
                new SynchronizedRandomAccessList<>(list) :
                new SynchronizedList<>(list)); // 使用静态内部类强化该集合引用，使得它拥有一个锁对象，
    }
// 静态内部类
static class SynchronizedList<E>
        extends SynchronizedCollection<E>
        implements List<E> {
        private static final long serialVersionUID = -7754090372962971524L;

        final List<E> list;

        // 
        SynchronizedList(List<E> list) {
            super(list);
            this.list = list;
        }
    }
    
static class SynchronizedCollection<E> implements Collection<E>, Serializable {
        private static final long serialVersionUID = 3053995032091335093L;

        final Collection<E> c;  // Backing Collection
        final Object mutex;     // Object on which to synchronize

        SynchronizedCollection(Collection<E> c) {
            this.c = Objects.requireNonNull(c);
            // 其实这个锁就是对象本身，即Collections.synchronizedList主要
            //就是给不安全的集合对象引用加一个它自身的对象锁,这样在每次操作
            //对象的时候就可以在该唯一对象上加锁，已达到同步的目的。后续集合
            //的操作都是依赖这个对象进行加锁同步的
            mutex = this;
        }
    }
    
// 操作方法
 public boolean add(E e) {
            // 使用之前拿到的锁进行同步，实际的添加操作是在对应的实现类里面实现的(ArrayList)
            // 插入的实现是较为高效的，与CopyOnWriteArrayList类的每次添加一个元素都要进行数组拷贝相比，
            //Collections下对集合的操作是借助具体实现类（ArrayList）的动态扩容来实现的，所以效率较高
            synchronized (mutex) {return c.add(e);}
        }
 public E get(int index) {
            synchronized (mutex) {return list.get(index);}
        }
```
##### 4、Collections.synchronized*()：
> 1、在Collections辅助类中，可以使用其线程安全化的数据结构不仅限于集合类，map等数据结构也是支持的，具体如下表：

数据结构类型 | 构造方法
---|---
1、map         |public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)； 
2、list        |public static <T> List<T> synchronizedList(List<T> list)；
3、set         |public static <T> Set<T> synchronizedSet(Set<T> s)；    
4、sortMap     |public static <K,V> SortedMap<K,V>
5、SortedSet   |public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s)     
6、NavigableMap|public static <K,V> NavigableMap<K,V> synchronizedNavigableMap(NavigableMap<K,V> m)
7、NavigableSet|public static <T> NavigableSet<T> synchronizedNavigableSet(NavigableSet<T> s)  
> 2、Collections辅助类实现各个数据类型的原理基本都是一样的，具体见 3 中举例的对ArraryList实现。

#### 2、map类：
##### 1、ConcurrentHashMap:
> 1、多线程中使用hashMap的首选，在jdk1.8中对其进行了优化，具体优化内容可参考https://github.com/bin-github/my-notes/blob/master/notes/Java8%E7%9A%84ConcurrentHashMap.md

> 2、ConcurrentHashMap中，主要是对多个key进行hash后值相同而需要放到map中同一个位置时，这个位置变为一个Node链表，每次的存取只需要在这个Node链表上加锁就可以了，这样并发性提高了很多，jdk1.8中就是使用synchronized关键字给该块链表加锁。

> 3、get时，使用sun.misc.Unsafe.getObjectVolatile方法原子可见性的取到Node对象。（如果这个Node正在被写对象加锁占用，则无法获取，但是如何感知synchronized关键字修饰该链表Node呢？？）
##### 2、ConcurrentSkipListMap:
> 1、线程安全的map，可实现map中key以插入顺序或者自定义的Compare方法的规则进行排序存储，即有序map，功能类似于TreeMap的多线程安全类。

```
public ConcurrentSkipListMap() {
        this.comparator = null;
        initialize();
    }
public ConcurrentSkipListMap(Comparator<? super K> comparator) {
        this.comparator = comparator;
        initialize();
    }
```
> 2、其底层是使用跳表结构实现的，key和value不可为null，它的put、get等操作方法的实现是没有使用锁的，不管是lock类的还是synchronized都没有使用，主要是使用底层的CAS技术获取对象==》多次比较，如果多次比较对象已变==》再次循环（无限循环）来实现的（算法较为复杂）。
>> 1、无锁编程（Lock-Free），Java中是有基于CPU的cas操作的原子性来实现高并发的，主要的实现就是SkipListMap，无锁编程的开发和维护难度很高，而且在现阶段主要的实现数据结构有：链表，栈，堆。一般在实际的工程系统中，还是使用锁技术来实现并发业务。这里是一个关于无锁编程的博客：http://blog.csdn.net/heiyeshuwu/article/details/40783981

##### 3、ConcurrentSkipListSet：
> 1、其实是ConcurrentSkipListMap的一个包装，实际的数据存取操作都是使用ConcurrentSkipListMap来实现的，

```
private final ConcurrentNavigableMap<E,Object> m;
// 构造方法
public ConcurrentSkipListSet() {
        m = new ConcurrentSkipListMap<E,Object>();
    }
    
// 添加方法，set集合的元素是map的key的集合，value是使用一个Boolean填充。
public boolean add(E e) {
        return m.putIfAbsent(e, Boolean.TRUE) == null;
    }
```
> 2、一个线程安全的、有序的、set集合结构。其作用类似TreeSet

#### 3、queue队列类：
