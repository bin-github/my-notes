#### 标记-压缩算法
##### 1、概述：该算法是标记算法和复制算法相结合的算法。它能解决标记算法的内存碎片问题和复制算法的内存利用率问题。
###### 1、Lisp2
> 1、 执行过程：**3次扫描清理堆**
>> 1、先扫描整个要清理的堆，给活动对象设置 forwarding 指针，即标记活动对象；   
>> 2、更新 forwarding 指针，更新其地址为即将要复制的地址；   
>> 3、移动对象，将已标记的活动对象移动到已更新的 forwarding 指针所指的地址。

> 2、优缺点：
>> 1、如它的算法描述，主要是消除清理堆中的内存碎片、提高堆的利用率；    
>> 2、耗时，每次清理都要扫描3次堆空间。

###### 2、Two - Finger
> 1、执行过程：**2次扫描清理堆**
>> 1、前提条件：**对象的大小是固定的**。   
>> 2、移动对象：一个头引用head，一个为引用tail，head找到非活动对象时就停止，tail找到活动对象停止，然后将对象互换，直到head和tail相交（相遇之后各自加一个对象，head就是活动对象的末尾，可分配堆的开始位置）；    
>> 3、修改引用：Two - Finger方法在复制之后原来的对象还是存在的，在head引用的右边，更新右边对象被引用的地址为现在对象的地址，即修改对象gc前后的对象引用。

> 2、优缺点：
>> 1、扫描堆的次数少了，提高了吞吐量；原对象不会消失，无需给对象额外分配一个字的空间用作记录引用地址，可使用堆空间更大。   
>> 2、移动式没有规律的，移动前和后的对象顺序大，相关的对象存储可能很远，缓存利用率很低；对象的大小固定，浪费一定的空间，尤其是大对象和小对象大小差距较大时。
###### 3、表格算法: 和Lisp2类似，实现变复杂，整体更高效。
> 1、执行过程：先找到连续的活动对象（群），移动对象群，构建“间隙表格”（间隙表格：记录原对象的起始地址和大小），主要用于后面对象引用的更新；再根据“间隙表格”更新对象引用。   

> 2、和Lisp2的异同：使用“间隙表格”，无需给每个对象开辟一个字的空间保存原对象的引用，直接移动活动对象群。减少了一次对堆的扫描。但在实现“间隙表格”时使得该算法变的复杂。

> 3、优缺点：
>> 1、对象有序，可利用缓存的优势；2次扫描，吞吐量提高；   
>> 2、间隙列表实现复杂，查询间隙表格的时间开销无法避免。

###### 3、ImmixGC算法


>> 1、
