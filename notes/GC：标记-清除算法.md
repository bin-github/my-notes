#### GC：标记-清除算法
##### 1、标记阶段：
> 1、从根节点开始，**遍历对象**，以深度优先算法查找子对象，并做标记，将所有“活动对象都做上标记”，每个对象有一个特殊的flag位，以区别它是否已被标记过。（“非活动对象”是不会被标记的，因为它从根节点出发根本不可达）

> 2、Java中这个根节点可以是以下对象：

```
Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.
Thread - 活着的线程
Stack Local - Java方法的local变量或参数
JNI Local - JNI方法的local变量或参数
JNI Global - 全局JNI引用
Monitor Used - 用于同步的监控对象
Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。
```


> 1、

##### 2、清除阶段：
###### 1、清除流程：
> 1、collector 会遍历整个堆，回收没有打上标记的对象（即垃圾），使其能再
次得到利用，有被标记的对象，设置其标志位为未标记，下次“标记阶段”继续标记。

> 2、回收对象主要是：将该对象的地址添加到**一个**“空闲链表”的单链表中，这样，这块内存下次就可以被用作分配对象的可用内存了。

> 3、在清除阶段，程序会遍历所有堆，进行垃圾回收。也就是说，所花费时间与堆大小成正
比。堆越大，清除阶段所花费的时间就会越长。
###### 2、特殊过程：
> 1、分配：当 mutator 申请分块时,搜索空闲链表并寻找大小合适的分块，这项操作就叫作分配。如下伪代码：pickup_chunk方法会在空闲链表中查找一个大小合适的内存块来作为分配的内存。查找空闲链表中大小合适的情况有三种。

```
new_obj(size){
    chunk = pickup_chunk(size, $free_list)
    if(chunk != NULL)
        return chunk
    else
        allocation_fail()
}

```
> 2、分配——查找链表的策略
>> 1、First - fit：在 pickup_chunk() 函数中，最初发现大于等于
size 的分块时就会立即返回该分块。

>> 2、Best - fit：遍历空闲链表，返回大于等于 size 的最小分块，这种策略叫
作 Best - fit。

>> 3、Worst - fit：找出空闲链表中最大的分块，将其分割成 mutator 申请的
大小和分割后剩余的大小，目的是将分割后剩余的分块最大化。（产生大量的小块，即内存碎片）

> 3、合并：根据分配策略的不同可能会产生大量的小分块。但如果它们是连续的，
我们就能把所有的小分块连在一起形成一个大分块。这种“连接连续分块”的操作就叫作合
并（coalescing），合并是在清除阶段进行的。

##### 3、优缺点：
###### 1、优点：实现简单、与保守式GC算法兼容（保守式gc算法：不移动对象在内存中的地址）
###### 2、缺点：
> 1、分配时带来的内存碎片化。碎片化带来的问题：1、分配时不能将大于碎片空间的对象分配给碎片空间，这样无形中增加了查找空闲链表中可用块的时间。降低分配速度。

> 2、分配速速：内存碎片的问题导致分配速度的下降。（遍历整个空闲链表，有可能还找不到大小合适的内存块）

> 3、与写时复制技术不兼容：写时复制技术（copy - on - write）：在 Linux 中复制进程，也就是使用 fork() 函数时，大部分内存空间都不会被复制。在各个进程中读数据时，能够访问共享内存没什么问题。然而，当我们对共享内存空间进行写入时，要复制自己私有空间的数据，对这个私有空间
进行重写。复制后只访问这个私有空间，不访问共享内存。   </br> 这样的话，GC 标记 - 清除算法就会存在一个问题 — 与写时复制技术不兼容。即使没
重写对象，GC 也会设置所有活动对象的标志位，这样就会频繁发生本不应该发生的复制，
压迫到内存空间。

##### 4、多个空闲链表：
###### 1、针对标记清除gc方案中的缺点，内存碎片化带来的分配速度变慢的问题进行优化。
> 1、原始标记清除法的空闲链表只有一个，不管内存块的大小，全部链接到一个链表中，这样，在分配时，找到大小合适的内存块需要遍历的次数无形中就增大了，如果将原来的一个链表根据大小分成多个链表，这样在分配时，就可以根据分配的大小找到特定大小的链表，分配速度就会提高很多，多链表反就是根据这点优化的。

##### 5、BiBOP法：
###### 1、BiBOP法也是对内存碎片的一个优化方案：
> 1、把堆分割成固定大小的块，让每个块只能配置同样大小的对象。提高内存的使用效率。
